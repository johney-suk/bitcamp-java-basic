package day01;
// 변수(Variable)
// Ex01에서 설명했듯이
// 변수란 공간의 값이 변경 가능한 공간을 변수라고 한다.
// 변수는 선언과 할당으로 이루어져 있다.
// 변수의 선언이란
// 해당 변수 공간에 어떠한 종류의 값이 들어가는 지와 그 공간의 이름을 정해주는 것을
// 선언 이라고 한다.
// 할당이란 해당 공간에 선언되어 있는 종류의 값을 넣는 것을 할당이라고 한다. 

// 변수에 들어갈 수 있는 값의 종류는 크게 2가지가 있다.
// 1. 기본형
//		기본형에는 8가지 종류의 값이 정의되어 있다.
//		byte short int long float double char boolean
//		A) 정수형
//			정수란? 소숫점이 없는 숫자들
//			byte:	8비트
//					비트란 2진법 자리수 1개를 뜻한다. 즉 8비트는 8자리 2진법 숫자를 뜻한다.
//					-2의 7승부터 2의 7승 - 1 까지 총 256개의 숫자가 들어가 있다.
//					2의 7승 - 1 까지인 이유는 0이 포함되기 때문!
//			short:	16비트 
//					-2의 15승부터 2의 15승 -1 까지
//			int:	32비트 (자바에서 정수를 우리가 적으면 자동으로 int로 인식된다)
//					-2의 31승부터 2의 31승 -1 까지
//			long: 	64비트
//					-2의 63승부터 2의 63승 -1 까지
//		B) 실수형
//			실수란?	소숫점이 있는 숫자들
//			float:	32비트를 이용하여 실수 표기
//			double: 64비트를 이용하여 실수 표기 (자바에서 우리가 실수를 적으면 자동으로 double로 인식)
//		c) 문자형
//			char: character의 줄임말.
//				  ASCII 테이블이라는 특수문자표를 참조하여
// 				    글자를 하나만 넣을 수 있다.
//				  ' ' 사이에 필요한 글자를 하나 넣어주면 된다.
//		D) 논리형
//			boolean: 참/거짓 2개의 값만 가진다.
//					 true/false

// 2. 참조형
//		참조형은 크게 3가지가 있는데
//		배열, 클래스, 인터페이스 3가지 종류가 있다.

public class Ex02Variable {
	public static void main(String[] args) {
		// 변수 선언하기
		// 자료형 이름
		int number;
		// 변수에 값 할당하기
		// 변수이름 = 값;
		// 프로그래밍에서 = 은 같다 라는 부등호가 아닌
		// 오른쪽의 값을 왼쪽 공간에 할당하겠다고 말하는
		// 할당 연산자가 된다.
		number = 10;
		
		System.out.println("number의 현재 값: " + number);
		
		number = 25;
		System.out.println("number의 현재 값: " + number);
		
		// 형변환 (typecasting)
		// 형변환이란 내가 입력한 값을 자바에서 다른 종류로 바꿔주는 것
		
		// 자바에는 2가지 형변환이 있는데
		// 암시적 형변환(implicit typecasting)과
		// 명시적 형변환(explicit typecasting)이 존재한다.
		
		// 암시적 형변환이란
		// 우리가 특별히 명령어를 적어주지 않더라도
		// 자바 내부적으로 자동으로 변수의 자료형(데이터타입)을 바꿔주는 것을
		// 암시적 형변환이라고 한다.
		// 암시적 형변환은 정수를 실수로 바꿀 때나 혹은
		// 더 작은 데이터타입을 더 큰 데이터타입으로 바꿀 때 발생한다.
		
		// 현재 number의 데이터타입은 int이다.
		// number를 실수형 변수 공간에 넣을 때 암시적 형변환이 발생한다.
		
		double myDouble = number;
		System.out.println("myDouble의 현재 값: " + myDouble);
		
		// 혹은 int를 long에 담을 때에도
		// 암시적 형변환이 발생한다.
		long myLong = number;
		System.out.println("myLong의 현재 값: " + myLong);
		
		// 명시적 형변환은 더 큰 데이터타입의 값을
		// 더 작은 데이터타입에 넣을 때 실행된다.
		
		// 이때에는 데이터의 표시범위가 더 좁아지기 때문에
		// 명시적으로 우리가 "바꿔도 괜찮아"라고 명령어를 적어주어야 한다.
		// 표시범위를 벗어나서 발생하는 오버플로우와 언더플로우라는 버그가 존재하기 때문에 
		// 우리가 명시적으로 형변환을 해주어야 한다!
		
		// number = myLong;
		// 위 코드는 더 큰 데이터타입의 값을 더 작은 데이터타입의 변수로 옮기려고 했기 때문에
		// 에러가 난다.
		// 명시적 형변환을 해주어야 한다.
		// 명시적 형변환은 저장할 변수 = (바꿀 데이터타입)값 으로 해주면 된다.
		number = (int)myLong;
		
		// 이 명시적 형변환을 할 때
		// 주의해야 하는 버그를 보자.
		// overflow
		// 해당 데이터타입의 최대 표시 범위를 벗어나는 경우
		// 오히려 최소값으로 가버리는 현상
		byte myByte = 10;
		System.out.println("myByte의 현재값: " + myByte);
		
		// byte 최대 값은 2^7 - 1이기 때문에 127이 된다.
		myByte = 127;
		System.out.println("myByte의 현재값: " + myByte);
		
		myByte = (byte)130;
		System.out.println("myByte의 현재값: " + myByte);
		
		myByte = -128;
		System.out.println("myByte의 현재값: " + myByte);
		
		myByte = (byte)-130;
		System.out.println("myByte의 현재값: " + myByte);
		
		// 컴퓨터에서 숫자를 표시할 때
		// 가장 왼쪽 자리는 0이면 +, 1이면 -가 된다.
		// 그러면 10을 2진법 byte로 표시하면
		// 0000 1010이 된다.
		
		// 10진법이란 각 자리가 0~9까지 10가지 숫자로 이루어져 있고
		// 각 자릿수가 오른쪽부터 10의 0승, 1승, 2승 이런 식으로 이루어진다.
		// 그렇다면
		// 782는 무슨 뜻일까?
		// 2*10^0 + 8*10^1 + 7*10^2 이란 뜻이다.
		
		// 마찬가지로 2진법은 각 자리가 0~1까지 2가지 숫자로 이루어져 있고
		// 각 자릿수가 오른쪽부터 2의 0승, 1승, 2승.. 이런 식으로 이루어진다.
		// 1110은 무슨 뜻일까?
		// 0*2^0 + 1*2^1 + 1*2^2 + 0*2^3 이 된다.
		// 따라서 14가 된다.
		
		// 그렇다면 8비트 숫자 중에서 가장 큰 숫자는
		// 얼마가 되는가? (단 가장 왼쪽은 0이면 +, 1이면 -인 것을 기억하자)
		// 0111 1111 -> (2^7 - 1) 이니까 127이 된다.
		// 그러면 127 + 1 은 얼마가 되는가?
		// 128
		// 128은 2^8이니까
		// 1000 0000 이 된다.
		
		// 10진법 기준
		// -1이 클까요 -999가 클까요?
		
		// 위의 경우 우리가 -라는 부호가 있으니까 -1이 더 크다라고 해줄 수 있지만
		// 부호가 없다면?
		// 1000 0000 이 클까 1111 1111 이 클까?
		
		// -128 + 1 = -127
		
		// 1000 0000 + 0000 0001 을 하는 것이다.
		// 하면은 1000 0001 이 된다.
		// 그렇게 1씩 오르다가
		// 1111 1111 이 되면 -1이 된다. 
		// 그럼 1111 1111 + 0000 0001 을 하게 되면?
		// 1 0000 0000 이 됨
		// 하지만 byte는? 8자리만 인정한다.
		// 즉 가장 왼쪽 1이 짤리면서
		// 0000 0000 즉 0이 된다.
		
		// 다시 원론으로 돌아가서
		// 0111 1111 즉 127에 1을 더하면?
		// 1000 0000 이 된다.
		// 즉 -128로 돌아가게 되는 것이다.
		
		// 이렇게 숫자의 최대 범위를 벗어난 숫자를 넣으면
		// 오히려 음의 최솟값으로 빠지는 것을 overflow라고 한다.
		
		// 반대로 숫자의 최소 범위를 벗어난 숫자를 넣어서
		// 양의 최대값으로 빠지는 것을 underflow라고 한다.
		
	}
}